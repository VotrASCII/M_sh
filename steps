1. basis of shell
initialize:
	read
	execute configuration file
interpret:
	stdin input
	execute
terminate:
	shell executes shutdown commands
	free memory
	terminate

2. /* DONE!!
HANDLING COMMANDS
read:
	commands from the user input
parse:
	separate command strings into:
		program
		arguments
execute:
	run parse commands
*/

3. /* DONE!!
READING input
dynamic memory allocation
input character is "int":
	EOF is an integer value (-1)
	while(1):
		c=ord(input()) #ASCII value of input character
		if c==EOF or c=='\n':
			end of command
*/
Problems/Doubts:
	->using the function i.e. without "getline()", the #(input) in the buffer = 8. WHY??
	->"ssize_t buf"; "print(buf)" returns 120. (Functionality unable to comprehend) 
	  ssize_t buf: size of block that can be read or written in single file operation

4. PARSING the input/TOKENIZING
simplifications to consider:
	no escape sequence
	just white space to separate the arguments
	eg: "copy f1 f2" denotes f1 and f2 as separate arguments
parsing: tokenize with white space as delimiter
"strtok()": library function to achieve parsing
	similar to "read":
		dynamic allocation of buffer to expand in case of commands get oversized
	different: null terminated array of pointers taken into consideration


5. EXECUTION

6. COMMANDS:
	"copy $1 $2"
	--> open file in read mode ($1)
	--> open file in write mode($2)
	int fd = open(const char* path, int access_mode, mode_t permission)
	return -1 on error and errorno set accordingly
	--> read-ing from file $1
	ssize_t read(int fd, void *buf, size_t size):
		done till EOF is reached or if sizeof($1)>sizeof(buf)
			read portion of data and write it in respective file $2
		else
			copy the entire thing to $2
	--> write-ing to file $2
	ssize_t write(int fd, void *buf, size_t size):
		written consecutively to another file according to the "buf" size pertaining to above condition
	--> close both files
	PROBLEM: "SOLVED!!"
		redundant data added to new file; Solution: See fstat API, struct fs
	/* add		
		struct fstat fs;
		fstat(int file_descriptor, &fs);
		BUF=fs.st_size;
		char buffer[BUF];
	*/
